/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package hykyx.ds;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import javax.swing.JLabel;
import java.awt.Font;
import java.awt.RenderingHints;
import javax.swing.JOptionPane;
/**
 *
 * @author Franklin Xam
 */
public class GridPanel extends javax.swing.JPanel {
    private final List<Edge> edges = new ArrayList<>(); // handling the edge 
                                                        // list of the graph
    
    private final List<Node> nodes = new ArrayList<>(); // handling the vertex
                                                        // list of the graph
    private  Set<Edge> paths = new HashSet<>();
            
            
    // constants
    private final int nodeRadius = 25;
    private final int cellSize = 5;
    private final Font nodeFont = new Font("SansSerif", Font.BOLD, 18);
    private final Font edgeFont = new Font("SansSerif", Font.BOLD, 14);
    private final Random rnd = new Random();
    private final Dijkstra d = new Dijkstra(nodes, edges, paths, this);
    private final RandomGraph g;
    
    // operation variables
    protected Mode opMode = Mode.VIEW;
    protected Node source, dest;
    protected boolean ready = false;
    
    
    /**
     * Creates new form GridPanel
     */
    public GridPanel() {
        initComponents();
        jLabel1.setText("" + opMode);
        g = new RandomGraph
                .Builder()
                .edges(edges)
                .nodes(nodes)
                .rnd(rnd).build();
        
        this.addMouseListener(new MouseHandler(this));
        this.addKeyListener(new KeyHandler(this));
        this.setFocusable(true);
        
    }

    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();

        setMinimumSize(new java.awt.Dimension(760, 435));

        jLabel1.setFont(new java.awt.Font("Segoe UI", 0, 48)); // NOI18N
        jLabel1.setText("jLabel1");

        jButton1.setText("Tutorial");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel2.setFont(new java.awt.Font("Segoe UI", 0, 24)); // NOI18N
        jLabel2.setText("Min cost to node:");

        jLabel3.setFont(new java.awt.Font("Segoe UI", 0, 24)); // NOI18N
        jLabel3.setText("None");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel1))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(19, 19, 19)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 391, Short.MAX_VALUE)
                        .addComponent(jButton1)))
                .addGap(15, 15, 15))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(15, 15, 15)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton1)
                    .addComponent(jLabel2)
                    .addComponent(jLabel3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 315, Short.MAX_VALUE)
                .addComponent(jLabel1)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        JOptionPane.showMessageDialog(this,
                        ""
                        + "Controls: "
                        + "\n[W] = Insert mode"
                        + "\n [E] = Edge mode"
                        + "\n [R] = Insert"
                        + "\n [G] = Create Random Graph"
                        + "\n [Q] = Step by Step mode "
                        + "\n\nRANDOM GRAPH \ncreates random graph"
                        + " when inputting numbers in the textbox"
                        + "\nINSERT MODE \nallows for the addition"
                        + " and removal of nodes"
                        + "\nEDGE MODE \nallows for the addition and "
                        + "removal of edges. Also allows weight edifing of edges"
                        + "\nVIEW MODE \nallows for the Dijkstra's algorithm"
                        + " execution"
                        + "\nSTEP MODE\n allows for the Dijkstra's algorithm to run"
                        + " sequentially\n\n"
                        + "LEFT MOUSE FUNCTIONS:"
                        + "\nINSERT MODE: adds node in the position of the mouse"
                        + "\nEDGE MODE: adds connection when two nodes are chosen"
                        + "\n              Weight editing can be done by clicking the "
                        + "edge weight"
                        + "\nVIEW MODE: performs Dijkstra's algorithm when two nodes"
                        + " are chosen"
                        + "\nSTEP MODE: perform Dijkstra's algorithm"
                        + " sequentially when two nodes are chosen"
                        + "\n\nRIGHT MOUSE FUNCTIONS:"
                        + "\nINSERT MODE: removes node when right mouse is clicked"
                        + "\nEDGE MODE: removes connection when two nodes"
                        + " are chosen"
                        + "\nVIEW MODE: resets the view (removes selection)", "Tutorial", JOptionPane.PLAIN_MESSAGE);
        this.requestFocus();
    }//GEN-LAST:event_jButton1ActionPerformed
    private void addNode(Node node) {
        nodes.add(node);
    }
    private void addEdge(Node start, Node end) {
        for(Edge e: edges) {
            if(isIncident(start, e) && isIncident(end, e)) return;
        } // checking if an edge already exists in-between the 
          // nodes
        
        edges.add(new Edge(start, end, 
                rnd.nextInt(20)  + 1)); // create new node
        
    }
    private void removeNode(int x, int y) {
        Node n = getNode(x, y);
        edges.removeIf(edge -> edge.source == n || edge.dest == n);
        if(n != null) nodes.remove(n);
    }
// --------------------------Left Click Methods---------------------------------
    private void handleAddEdge(int x, int y) {
        Node clickedNode = getNode(x, y);
        if (clickedNode != null && source == null) {
            source = clickedNode;
            return;
        }

        dest = getNode(x, y);
        if (dest != null && source != null && dest != source) {
            addEdge(source, dest);

            // Reset Selection
            handleResetView();
        } else if (source != null) {
            // If we right click empty space, cancel the edge creation
            source = null;
        } 
    }
    private void handleAddNode(int x, int y) {
        int snappedX = (x / cellSize) * cellSize;
        int snappedY = (y / cellSize) * cellSize;
        if (getNode(x, y) == null) {
            Node n = new Node("" + getNextAvailableId(), 
                    snappedX, snappedY);
            addNode(n);
        }
    }
    private void handleStepping(int x, int y) {
        prepare(x, y);
        if(ready) startSteps(source, dest);
    }
    private void handleRunDijsktra(int x, int y) {
        // Selection of source node for the dijsktra algorithm
        prepare(x, y);
        if(ready) runDijsktra(source, dest); // run the algorithm  
    }
    // calculating the cost when using this node to traverse

    
    public void handleLeftClick(MouseEvent e) {
        int rawX = e.getX();
        int rawY = e.getY();

        switch (opMode) {
            case Mode.INSERT:
                handleAddNode(rawX, rawY);
                break;
            case Mode.EDGE:
                handleAddEdge(rawX, rawY);
                editEdgeWeight(rawX, rawY);
                break;
            case Mode.VIEW:
                handleRunDijsktra(rawX, rawY);
                break;
            case Mode.STEP:
                handleStepping(rawX, rawY);
                break;
        }
        repaint();
    }
    private boolean editEdgeWeight(int mouseX, int mouseY) {
        for (Edge edge : edges) {
            // Calculate the center of the edge
            int midX = (edge.source.x + edge.dest.x) / 2;
            int midY = (edge.source.y + edge.dest.y) / 2;

            // Calculate distance from mouse click to the center
            double dx = mouseX - midX;
            double dy = mouseY - midY;

            // If clicked within 15 pixels of the center number
            // 15 * 15 = 225
            if ((dx * dx + dy * dy) < 225) {

                String input = JOptionPane.showInputDialog(this,
                        "Enter new weight:", 
                        edge.weight);

                if (input != null && !input.isEmpty()) {
                    try {
                        edge.weight = Integer.parseInt(input);
                        repaint(); // Redraw immediately
                    } catch (NumberFormatException ex) {
                    }
                }
                return true; // We handled the click
            }
        }
        return false; // No weight was clicked
    }
    
//    ------------------ Right Click Methods ---------------------------------
    private void handleDeleteEdge(int x, int y) {
        Node clickedNode = getNode(x, y);
        if (clickedNode != null && source == null) {
            source = clickedNode;
            return;
        }

        dest = getNode(x, y); // set the destination node
        if (dest != null && source != null && dest != source) {
            System.out.println("clicked node");
            edges.removeIf(edge -> isIncident(source, edge) 
                    && isIncident(dest, edge));
            // Reset Selection
            handleResetView();
        } else if (source != null) {
            // If we right click empty space, cancel the edge creation
            source = null;
        }
    }
    
    private void handleResetView() {
         if(source != null) {
            source = null;
        } if(dest != null) {
            dest = null;
        }
        ready = false;
        jLabel3.setText("None");
        jLabel2.setText("Min cost to node: ");
        if(paths != null) paths.clear();
        d.reset();
    }
    private void handleDeleteNode(int x, int y) {
        removeNode(x, y);
    }
    
    public void handleRightClick(MouseEvent e) {
        int rawX = e.getX();
        int rawY = e.getY();
        switch(opMode) {
            case Mode.INSERT:
                handleDeleteNode(rawX, rawY);
                break;
            case Mode.EDGE:
                handleDeleteEdge(rawX, rawY);
                break;
            case Mode.VIEW:
                handleResetView();
                break;
        }
        repaint();

    }
//--------------------------------- Helper Functions -------------------------
   private String getNextAvailableId() {
        // Collect all currently used IDs into a Set for fast lookup
        Set<String> usedIds = new HashSet<>();
        for (Node n : nodes) {
            usedIds.add(n.id);
        }

        // Start counting from 0 and find the first number NOT in the set
        int i = 0;
        while (true) {
            String candidate = String.valueOf(i);
            if (!usedIds.contains(candidate)) {
                return candidate; // Found a gap! 
                //(e.g., if 0, 2 exist, this returns "1")
            }
            i++;
        }
    }
  protected void createRandomGraph(int n) {
       // generating a random graph with n nodes
       // within a W x H area
       g.generate(n, this.getWidth(), this.getHeight());
       if(paths != null) paths.clear();
       
       // redraw the screen;
       repaint();
   }
    private Node getNode(int x, int y) {
        for(int i = 0; i < nodes.size(); i++)  {
            Node node = nodes.get(i);
            // Pythagoras theorem for distance
            double dx = x - node.x;
            double dy = y - node.y;
            if((dx * dx + dy *dy) <= nodeRadius * nodeRadius) { 
                // check if the point is within the bounds 
                // (assume that the hitbox is a square)
                return node;
            }
        }

        return null;
    }  
    private void prepare(int x, int y) {
        if(ready) handleResetView();
        Node clicked = getNode(x, y);
        if(clicked == null) return ;
        if(source == null) {
          source = clicked;
        // Selection of destination node for the dijsktra algorithm   
        } else if(dest == null) { 
            dest = clicked;
            ready = true;
        } 
    }
    private boolean isIncident(Node a, Edge e) {
        return e.source == a || e.dest == a;
    }
    protected void changeMode(Mode op) {
        this.opMode = op;
        handleResetView();
        jLabel1.setText("" + opMode);
    }
    private void startSteps(Node start, Node end) {
       jLabel2.setText("Min cost from " + start.id + " to " + end.id + ": ");
        d.stepByStep(start, end, () -> {
            jLabel3.setText(end.minDist == Integer.MAX_VALUE ? 
            "∞"  :  "" + end.minDist);
            repaint();        
        });

    }
    private void runDijsktra(Node start, Node end) {
        jLabel2.setText("Min cost from " + start.id + " to " + end.id + ": ");
        d.dijsktra(start, end);
        jLabel3.setText(end.minDist == Integer.MAX_VALUE ? 
               "∞"  :  "" +end.minDist);
        repaint();
    }

// -----------------------Rendering Helper Functions---------------------------
    private void drawEdge(Graphics2D g2) {
        for (Edge edge : edges) {
            g2.setColor(paths.contains(edge) ? Color.green: Color.BLACK);
            g2.setStroke(new BasicStroke(2));
            g2.drawLine(edge.source.x,
                    edge.source.y,
                    edge.dest.x,
                    edge.dest.y);
            // Draw Weight background so text is readable over lines
            drawWeight(g2, edge);
        }
    }
    private void drawWeight(Graphics2D g2, Edge edge) {
        // get the midpoint
        int lineMidX = (edge.source.x + edge.dest.x) / 2;
        int lineMidY = (edge.source.y + edge.dest.y) / 2;
        
        // draw the text
        g2.setColor(Color.WHITE);
        g2.setFont(edgeFont);
        g2.fillRect(lineMidX - 5, lineMidY - 10, 20, 15); 
        g2.setColor(Color.BLACK);
        g2.drawString("" + edge.weight, lineMidX, lineMidY);
        //display the text
    }
    private void drawLabel(Node node, Graphics2D g2) {
        // Center Text
        FontMetrics fm = g2.getFontMetrics();
        int textWidth = fm.stringWidth(node.id);
        int textHeight = fm.getAscent();

        g2.setColor(Color.WHITE);
        g2.setFont(nodeFont);
        // Precise centering logic
        g2.drawString(node.id, 
                node.x - (textWidth / 2), 
                node.y + (textHeight / 2) - 2);
        g2.setColor(Color.BLACK);
        g2.drawString(node.minDist == Integer.MAX_VALUE ? "∞"  :
                ""+node.minDist, node.x + nodeRadius, node.y - nodeRadius);
    }
    private void drawNode(Graphics2D g2) {
        for (Node node : nodes) {
            setColor(g2, node);
            // Ternary operator for color
            
            // Fill circle
            g2.fillOval(node.x - nodeRadius, 
                    node.y - nodeRadius, 
                    nodeRadius * 2, 
                    nodeRadius * 2);

            // Draw Border
            g2.setColor(Color.BLACK);
            g2.drawOval(node.x - nodeRadius,
                    node.y - nodeRadius, 
                    nodeRadius * 2, 
                    nodeRadius * 2);
            // draw label
            drawLabel(node, g2);
        }
    }
    public void setColor(Graphics2D g2, Node node) {
        if (node.state == NodeState.PATH) g2.setColor(Color.GREEN);
        else if (node.state == NodeState.CLOSED) g2.setColor(Color.LIGHT_GRAY);
        else if (node.state == NodeState.OPEN) g2.setColor(Color.ORANGE);
        else if (node == source) g2.setColor(Color.CYAN); 
        else if (node == dest) g2.setColor(Color.MAGENTA);
        else g2.setColor(Color.RED); // Default/Unvisited
    }
// ---------------------------------------Paint method-------------------------
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;

        // Enable Anti-aliasing for smooth circles and lines
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, 
                            RenderingHints.VALUE_ANTIALIAS_ON);
        // Draw Edges
        drawEdge(g2);
        // Draw Nodes
        drawNode(g2);
        
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    // End of variables declaration//GEN-END:variables
}
