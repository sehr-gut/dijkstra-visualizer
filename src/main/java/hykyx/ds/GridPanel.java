/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package hykyx.ds;

import hykyx.priority_queue.Heap;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import javax.swing.SwingUtilities;

/**
 *
 * @author Franklin Xam
 */
public class GridPanel extends javax.swing.JPanel {
    private final List<Edge> edges = new ArrayList<>(); // handling the edge list of the graph
    private final List<Node> nodes = new ArrayList<>(); // handling the vertex list of the grap
    private  Set<Edge> paths = new HashSet<>();
    private final int nodeRadius = 20;
    private final int cellSize = 5;
    private Mode opMode = Mode.VIEW;
    private final Random rnd = new Random();
    private Node source, dest;
    private boolean ready = false;
    /**
     * Creates new form GridPanel
     */
    public GridPanel() {
        initComponents();
        jLabel1.setText("" + opMode);
        MouseAdapter ml = new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                handleMouse(e);
            }
            @Override
           public void mouseDragged(MouseEvent e) {
               handleMouse(e);
           }
        };
        KeyAdapter kl = new KeyAdapter() { // handle mode switching
            public void keyPressed(KeyEvent e) {
                switch(e.getKeyCode()) {
                    case KeyEvent.VK_W: // insert mode (insert/delete nodes)
                        opMode = Mode.INSERT;
                        break;
                    case KeyEvent.VK_E:// edge mode (adding edges)
                        opMode = Mode.EDGE;
                        break;
                    case KeyEvent.VK_R:// running the program
                        opMode = Mode.VIEW;
                        break;
                    case KeyEvent.VK_ENTER: // running dijsktra
                        if(ready) runDijsktra(source, dest);
                        System.out.println("hello");
                        break;
                 }
                jLabel1.setText("" + opMode);
                
            }
           
        };
        this.addMouseListener(ml);
        this.addKeyListener(kl);
        this.setFocusable(true);
        
    }

    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();

        setMinimumSize(new java.awt.Dimension(760, 435));

        jLabel1.setText("jLabel1");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(708, Short.MAX_VALUE)
                .addComponent(jLabel1)
                .addGap(15, 15, 15))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(413, Short.MAX_VALUE)
                .addComponent(jLabel1)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents
    public void addNode(Node node) {
        nodes.add(node);
        repaint();
    }
    public void addEdge(Node start, Node end) {
        for(Edge e: edges) {
            if(isAdjacent(start, e) && isAdjacent(end, e)) return;
        } // checking if an edge already exists in-between the 
          // nodes
        
        edges.add(new Edge(start, end, 
                rnd.nextInt(20)  + 1)); // create new node
        
        repaint(); // redraw the screen
    }
    public void removeNode(int x, int y) {
        Node n = getNode(x, y);
        edges.removeIf(edge -> edge.source == n || edge.dest == n);
        if(n != null) nodes.remove(n);
        repaint();
    }

    private void handleMouse(MouseEvent e) {
        int rawX = e.getX();
        int rawY = e.getY();
        
        int snappedX = (rawX / cellSize) * cellSize;
        int snappedY = (rawY / cellSize) * cellSize;
        if(SwingUtilities.isLeftMouseButton(e)) {
            if(opMode == Mode.INSERT){
                if (getNode(rawX, rawY) == null) {
                    Node n = new Node("" + nodes.size(), snappedX, snappedY);
                    addNode(n);
                }
            } if(opMode == Mode.EDGE) {
                Node clickedNode = getNode(rawX, rawY);
                if (clickedNode != null && source == null) {
                    source = clickedNode;
                    source.selected = true; // Set selection state here
                    repaint();
                    return;
                }
                
                dest = getNode(rawX, rawY);
                if (dest != null && source != null && dest != source) {
                    dest.selected = true;
                    addEdge(source, dest);

                    // Reset Selection
                    source.selected = false;
                    dest.selected = false;
                    source = null;
                    dest = null;
                    repaint();
                } else if (source != null) {
                    // If we right click empty space, cancel the edge creation
                    source.selected = false;
                    source = null;
                    repaint();
                } 
            } if (opMode == Mode.VIEW) {
                // Selection of source node for the dijsktra algorithm
                if(source == null) {
                    source = getNode(rawX, rawY);
                    if(source != null) source.selected = true;
                } else if(source != null && dest == null) { 
                    dest = getNode(rawX, rawY);
                    if(dest == null) return;
                    dest.selected = true;
                    ready = true;
                }
                repaint();
            }

        } if(SwingUtilities.isRightMouseButton(e)) {
            if(opMode == Mode.INSERT) {
                removeNode(rawX, rawY);
            } if(opMode == Mode.EDGE) {
                Node clickedNode = getNode(rawX, rawY);
                if (clickedNode != null && source == null) {
                    source = clickedNode;
                    source.selected = true; // Set selection state here
                    repaint();
                    return;
                }
                
                dest = getNode(rawX, rawY); // set the destination node
                if (dest != null && source != null && dest != source) {
                    dest.selected = true;
                    System.out.println("clicked node");
                    edges.removeIf(edge -> isAdjacent(source, edge) 
                            && isAdjacent(dest, edge));
                    // Reset Selection
                    source.selected = false;
                    dest.selected = false;
                    source = null;
                    dest = null;
                    repaint();
                } else if (source != null) {
                    // If we right click empty space, cancel the edge creation
                    source.selected = false;
                    source = null;
                    repaint();
                }
            }if(opMode == Mode.VIEW) {
                if(source != null) {
                    source.selected = false;
                    source = null;
                } if(dest != null) {
                    dest.selected = false;
                    dest = null;
                }
                
                if(paths != null) paths.clear();
                repaint();
            }
        }
    }
    public Node getNode(int x, int y) {
        for(int i = 0; i < nodes.size(); i++)  {
            Node node = nodes.get(i);
            // Pythagoras theorem for distance
            double dx = x - node.x;
            double dy = y - node.y;
            if((dx * dx + dy *dy) <= nodeRadius * nodeRadius) { 
                // check if the point is within the bounds 
                // (assume that the hitbox is a square)
                return node;
            }
        }

        return null;
    }  
    public void runDijsktra(Node start, Node end) {
        Dijsktra d = new Dijsktra(nodes, edges, paths);
        d.dijsktra(start, end);
        ready = false;
        repaint();
    }
    public boolean isAdjacent(Node a, Edge e) {
        return e.source == a || e.dest == a;
    }
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;

        // Enable Anti-aliasing for smooth circles and lines
        g2.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING, 
                            java.awt.RenderingHints.VALUE_ANTIALIAS_ON);

        

        // Draw Edges
        for (Edge edge : edges) {
            g2.setColor(paths.contains(edge) ? Color.green: Color.BLACK);
            g2.setStroke(new BasicStroke(2));
            g2.drawLine(edge.source.x, edge.source.y, edge.dest.x, edge.dest.y);
            
            // Draw Weight background so text is readable over lines
            int lineMidX = (edge.source.x + edge.dest.x) / 2;
            int lineMidY = (edge.source.y + edge.dest.y) / 2;
            g2.setColor(Color.WHITE);
            g2.fillRect(lineMidX - 5, lineMidY - 10, 20, 15); 
            g2.setColor(Color.BLACK);
            g2.drawString("" + edge.weight, lineMidX, lineMidY);
        }

        // Draw Nodes
        for (Node node : nodes) {
            g2.setColor(node.selected ? Color.BLUE : Color.RED); // Ternary operator for color

            // Fill circle
            g2.fillOval(node.x - nodeRadius, node.y - nodeRadius, nodeRadius * 2, nodeRadius * 2);

            // Draw Border
            g2.setColor(Color.BLACK);
            g2.drawOval(node.x - nodeRadius, node.y - nodeRadius, nodeRadius * 2, nodeRadius * 2);

            // Center Text
            FontMetrics fm = g2.getFontMetrics();
            int textWidth = fm.stringWidth(node.id);
            int textHeight = fm.getAscent();

            g2.setColor(Color.WHITE);
            // Precise centering logic
            g2.drawString(node.id, node.x - (textWidth / 2), node.y + (textHeight / 2) - 2);
        }
        
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    // End of variables declaration//GEN-END:variables
}
