/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package hykyx.ds;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import javax.swing.JLabel;
import javax.swing.SwingUtilities;
import java.awt.RenderingHints;
/**
 *
 * @author Franklin Xam
 */
public class GridPanel extends javax.swing.JPanel {
    private final List<Edge> edges = new ArrayList<>(); // handling the edge 
                                                        // list of the graph
    
    private final List<Node> nodes = new ArrayList<>(); // handling the vertex
                                                        // list of the graph
    private  Set<Edge> paths = new HashSet<>();
            
            
    // constants
    private final int nodeRadius = 20;
    private final int cellSize = 5;

    private final Random rnd = new Random();
    
    
    // operation variables
    protected Mode opMode = Mode.VIEW;
    protected Node source, dest;
    protected boolean ready = false;
    
    
    /**
     * Creates new form GridPanel
     */
    public GridPanel() {
        initComponents();
        jLabel1.setText("" + opMode);
        
        this.addMouseListener(new MouseHandler(this));
        this.addKeyListener(new KeyHandler(this));
        this.setFocusable(true);
        
    }

    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();

        setMinimumSize(new java.awt.Dimension(760, 435));

        jLabel1.setText("jLabel1");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(708, Short.MAX_VALUE)
                .addComponent(jLabel1)
                .addGap(15, 15, 15))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(413, Short.MAX_VALUE)
                .addComponent(jLabel1)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents
    private void addNode(Node node) {
        nodes.add(node);
        repaint();
    }
    private void addEdge(Node start, Node end) {
        for(Edge e: edges) {
            if(isIncident(start, e) && isIncident(end, e)) return;
        } // checking if an edge already exists in-between the 
          // nodes
        
        edges.add(new Edge(start, end, 
                rnd.nextInt(20)  + 1)); // create new node
        
        repaint(); // redraw the screen
    }
    private void removeNode(int x, int y) {
        Node n = getNode(x, y);
        edges.removeIf(edge -> edge.source == n || edge.dest == n);
        if(n != null) nodes.remove(n);
        repaint();
    }
// --------------------------Left Click Methods---------------------------------
    private void handleAddEdge(int x, int y) {
        Node clickedNode = getNode(x, y);
        if (clickedNode != null && source == null) {
            source = clickedNode;
            source.selected = true; // Set selection state here
            repaint();
            return;
        }

        dest = getNode(x, y);
        if (dest != null && source != null && dest != source) {
            dest.selected = true;
            addEdge(source, dest);

            // Reset Selection
            handleResetView();
        } else if (source != null) {
            // If we right click empty space, cancel the edge creation
            source.selected = false;
            source = null;
        } 
        repaint();
    }
    private void handleAddNode(int x, int y) {
        int snappedX = (x / cellSize) * cellSize;
        int snappedY = (y / cellSize) * cellSize;
        if (getNode(x, y) == null) {
            Node n = new Node("" + nodes.size(), snappedX, snappedY);
            addNode(n);
        }
    }
    private void handleRunDijsktra(int x, int y) {
        // Selection of source node for the dijsktra algorithm
        if(ready) handleResetView();
        Node clicked = getNode(x, y);
        if(clicked == null) return;
        if(source == null) {
          source = clicked;
          source.selected = true;
        // Selection of destination node for the dijsktra algorithm   
        } else if(dest == null) { 
            dest = clicked;
            dest.selected = true;
            ready = true;
        } 
        
        if(ready) runDijsktra(source, dest); // run the algorithm  
        repaint();
    }
    // calculating the cost when using this node to traverse

    
    public void handleLeftClick(MouseEvent e) {
        int rawX = e.getX();
        int rawY = e.getY();

        switch (opMode) {
            case Mode.INSERT:
                handleAddNode(rawX, rawY);
                break;
            case Mode.EDGE:
                handleAddEdge(rawX, rawY);
                break;
            case Mode.VIEW:
                handleRunDijsktra(rawX, rawY);
                break;
        }
    }
    
    
//    ------------------ Right Click Methods ---------------------------------
    private void handleDeleteEdge(int x, int y) {
        Node clickedNode = getNode(x, y);
        if (clickedNode != null && source == null) {
            source = clickedNode;
            source.selected = true; // Set selection state here
            repaint();
            return;
        }

        dest = getNode(x, y); // set the destination node
        if (dest != null && source != null && dest != source) {
            dest.selected = true;
            System.out.println("clicked node");
            edges.removeIf(edge -> isIncident(source, edge) 
                    && isIncident(dest, edge));
            // Reset Selection
            handleResetView();
            repaint();
        } else if (source != null) {
            // If we right click empty space, cancel the edge creation
            source.selected = false;
            source = null;
            repaint();
        }
    }
    
    private void handleResetView() {
         if(source != null) {
            source.selected = false;
            source = null;
        } if(dest != null) {
            dest.selected = false;
            dest = null;
        }
        ready = false;
        if(paths != null) paths.clear();
        repaint();
    }
    private void handleDeleteNode(int x, int y) {
        removeNode(x, y);
    }
    
    public void handleRightClick(MouseEvent e) {
        int rawX = e.getX();
        int rawY = e.getY();
        switch(opMode) {
            case Mode.INSERT:
                handleDeleteNode(rawX, rawY);
                break;
            case Mode.EDGE:
                handleDeleteEdge(rawX, rawY);
                break;
            case Mode.VIEW:
                handleResetView();
                break;
        }
    }
//--------------------------------- Helper Functions -------------------------
    private Node getNode(int x, int y) {
        for(int i = 0; i < nodes.size(); i++)  {
            Node node = nodes.get(i);
            // Pythagoras theorem for distance
            double dx = x - node.x;
            double dy = y - node.y;
            if((dx * dx + dy *dy) <= nodeRadius * nodeRadius) { 
                // check if the point is within the bounds 
                // (assume that the hitbox is a square)
                return node;
            }
        }

        return null;
    }  

    private boolean isIncident(Node a, Edge e) {
        return e.source == a || e.dest == a;
    }
    protected void changeMode(Mode op) {
        this.opMode = op;
        handleResetView();
    }
    private void runDijsktra(Node start, Node end) {
        Dijsktra d = new Dijsktra(nodes, edges, paths);
        d.dijsktra(start, end);
        repaint();
    }
    public JLabel getLabel() {
        return jLabel1;
    }
// -----------------------Rendering Helper Functions---------------------------
    private void drawEdge(Graphics2D g2) {
        for (Edge edge : edges) {
            g2.setColor(paths.contains(edge) ? Color.green: Color.BLACK);
            g2.setStroke(new BasicStroke(2));
            g2.drawLine(edge.source.x,
                    edge.source.y,
                    edge.dest.x,
                    edge.dest.y);
            
            // Draw Weight background so text is readable over lines
            drawWeight(g2, edge);
        }
    }
    private void drawWeight(Graphics2D g2, Edge edge) {
        // get the midpoint
        int lineMidX = (edge.source.x + edge.dest.x) / 2;
        int lineMidY = (edge.source.y + edge.dest.y) / 2;
        
        // draw the text
        g2.setColor(Color.WHITE);
        g2.fillRect(lineMidX - 5, lineMidY - 10, 20, 15); 
        g2.setColor(Color.BLACK);
        g2.drawString("" + edge.weight, lineMidX, lineMidY);
        //display the text
    }
    private void drawLabel(Node node, Graphics2D g2) {
        // Center Text
        FontMetrics fm = g2.getFontMetrics();
        int textWidth = fm.stringWidth(node.id);
        int textHeight = fm.getAscent();

        g2.setColor(Color.WHITE);
        // Precise centering logic
        g2.drawString(node.id, 
                node.x - (textWidth / 2), 
                node.y + (textHeight / 2) - 2);
    }
    private void drawNode(Graphics2D g2) {
        for (Node node : nodes) {
            g2.setColor(node.selected ? Color.BLUE : Color.RED); 
            // Ternary operator for color

            // Fill circle
            g2.fillOval(node.x - nodeRadius, 
                    node.y - nodeRadius, 
                    nodeRadius * 2, 
                    nodeRadius * 2);

            // Draw Border
            g2.setColor(Color.BLACK);
            g2.drawOval(node.x - nodeRadius,
                    node.y - nodeRadius, 
                    nodeRadius * 2, 
                    nodeRadius * 2);
            // draw label
            drawLabel(node, g2);
        }
    }
// ---------------------------------------Paint method-------------------------
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;

        // Enable Anti-aliasing for smooth circles and lines
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, 
                            RenderingHints.VALUE_ANTIALIAS_ON);
        // Draw Edges
        drawEdge(g2);
        // Draw Nodes
        drawNode(g2);
        
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    // End of variables declaration//GEN-END:variables
}
